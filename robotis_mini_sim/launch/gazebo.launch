#!/usr/bin/env python3

from launch import LaunchDescription
from launch.actions import SetEnvironmentVariable, IncludeLaunchDescription, OpaqueFunction, DeclareLaunchArgument
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch.substitutions import PathJoinSubstitution, LaunchConfiguration
from launch_ros.actions import Node
from launch_ros.substitutions import FindPackageShare
from pathlib import Path

def generate_launch_description():
    # Package shares
    ros_gz_sim_share = FindPackageShare('ros_gz_sim')
    sim_pkg_share    = FindPackageShare('robotis_mini_sim')
    model_pkg_share  = FindPackageShare('robotis_mini_model')

    # Paths
    gz_server_launch = PathJoinSubstitution([ros_gz_sim_share, 'launch', 'gz_server.launch.py'])
    default_world = PathJoinSubstitution([sim_pkg_share, 'worlds', 'empty.world'])
    controllers_yaml = PathJoinSubstitution([sim_pkg_share, 'config', 'controllers.yaml'])

    # Args
    use_sim_time = DeclareLaunchArgument('use_sim_time', default_value='true')
    world = DeclareLaunchArgument('world', default_value=default_world)

    def _read_urdf(context):
        urdf = PathJoinSubstitution([model_pkg_share, 'urdf', 'robotis_mini.urdf']).perform(context)
        return Path(urdf).read_text()

    # Build the dynamic part after we have the context (to read URDF once)
    def build_nodes(context, *_, **__):
        robot_description_xml = _read_urdf(context)
        world_file = LaunchConfiguration('world')

        # 1) Start Gazebo server.
        gz = IncludeLaunchDescription(
            PythonLaunchDescriptionSource(gz_server_launch),
            launch_arguments={
                'world_sdf_file': world_file
            }.items()
        )

        # 2) Robot State Publisher (provides /robot_description)
        rsp = Node(
            package='robot_state_publisher',
            executable='robot_state_publisher',
            parameters=[{'use_sim_time': LaunchConfiguration('use_sim_time'),
                         'robot_description': robot_description_xml}],
            output='screen'
        )

        # 3) Spawn robot from /robot_description into running Gazebo
        spawn = Node(
            package='ros_gz_sim',
            executable='create',
            arguments=['-name', 'robotis_mini',
                       '-topic', 'robot_description',
                       '-allow_renaming', 'true'],
            output='screen'
        )

        # 4) Controllers and spawners (JSB, JTC)
        cm = Node(
            package='controller_manager',
            executable='ros2_control_node',
            parameters=[
                controllers_yaml,
                {'robot_description': robot_description_xml},
            ],
            output='both'
        )

        jsb = Node(
            package='controller_manager',
            executable='spawner',
            arguments=['joint_state_broadcaster'],
            output='screen'
        )
        jtc = Node(
            package='controller_manager',
            executable='spawner',
            arguments=['joint_trajectory_controller'],
            output='screen'
        )

        return [gz, rsp, spawn, cm, jsb, jtc]

    return LaunchDescription([
        use_sim_time,
        world,
        OpaqueFunction(function=build_nodes),
    ])
