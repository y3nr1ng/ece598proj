#!/usr/bin/env python3
import math
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from robotis_mini.action import ExecutePose

DEG = math.pi / 180.0

class InitOnce(Node):
    def __init__(self):
        super().__init__('init')

        self.cli = ActionClient(self, ExecutePose, '/execute_pose')
        self.get_logger().info('Waiting for /execute_pose...')
        self.cli.wait_for_server()

    def run(self, duration_sec: float = 5.0) -> bool:
        # Build a single “initial pose” goal
        g = ExecutePose.Goal()
        g.use_arms = True
        g.use_legs = True

        g.rh_x, g.rh_y, g.rh_z = 0.0, -0.174, -0.012
        g.lh_x, g.lh_y, g.lh_z = 0.0,  0.174, -0.012

        g.rf_x, g.rf_y, g.rf_z = 0.015, -0.033, -0.196
        g.lf_x, g.lf_y, g.lf_z = 0.015,  0.033, -0.196

        g.base_roll = g.base_pitch = 0.0

        g.duration_sec = float(duration_sec)

        # Send and wait synchronously
        send_fut = self.cli.send_goal_async(g)
        rclpy.spin_until_future_complete(self, send_fut)
        gh = send_fut.result()
        if not gh or not gh.accepted:
            self.get_logger().error('Initial-pose goal was rejected.')
            return False

        res_fut = gh.get_result_async()
        rclpy.spin_until_future_complete(self, res_fut)
        res = res_fut.result().result
        self.get_logger().info(f'init done: success={res.success} msg="{res.message}"')
        return bool(res.success)

def main():
    rclpy.init()
    node = InitOnce()
    try:
        ok = node.run()
        if not ok:
            node.get_logger().warn('Robot may not be in initial pose.')
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
